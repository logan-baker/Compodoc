"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var CommentChar_1 = require("./CommentChar");
var CodeBlockWriter = (function () {
    function CodeBlockWriter(opts) {
        this._currentIndentation = 0;
        this._text = "";
        this._newLineOnNextWrite = false;
        this._currentCommentChar = undefined;
        this._stringCharStack = [];
        this._newLine = (opts && opts.newLine) || "\n";
        this._useTabs = (opts && opts.useTabs) || false;
        this._indentNumberOfSpaces = (opts && opts.indentNumberOfSpaces) || 4;
        this._indentationText = getIndentationText(this._useTabs, this._indentNumberOfSpaces);
        this._quoteChar = (opts && opts.useSingleQuote) ? "'" : "\"";
    }
    CodeBlockWriter.prototype.setIndentationLevel = function (countOrText) {
        if (typeof countOrText === "number") {
            if (countOrText < 0)
                throw new Error("Passed in indentation level should be greater than or equal to 0.");
            this._currentIndentation = countOrText;
            return this;
        }
        else if (typeof countOrText === "string") {
            if (!/^[ \t]*$/.test(countOrText))
                throw new Error("Provided string must be empty or only contain spaces or tabs.");
            var _a = getSpacesAndTabsCount(countOrText), spacesCount = _a.spacesCount, tabsCount = _a.tabsCount;
            this._currentIndentation = tabsCount + Math.round(Math.max(0, spacesCount - 1) / this._indentNumberOfSpaces);
            return this;
        }
        else {
            throw new Error("Argument provided must be a string or number.");
        }
    };
    CodeBlockWriter.prototype.block = function (block) {
        this.newLineIfNewLineOnNextWrite();
        this.spaceIfLastNotSpace();
        this.inlineBlock(block);
        this._newLineOnNextWrite = true;
        return this;
    };
    CodeBlockWriter.prototype.inlineBlock = function (block) {
        this.newLineIfNewLineOnNextWrite();
        this.write("{");
        this._currentIndentation++;
        this.newLine();
        if (block != null)
            block();
        if (this._currentIndentation > 0)
            this._currentIndentation--;
        this.newLineIfLastNotNewLine().write("}");
        return this;
    };
    CodeBlockWriter.prototype.conditionalWriteLine = function (condition, str) {
        if (condition)
            this.writeLine(str);
        return this;
    };
    CodeBlockWriter.prototype.writeLine = function (str) {
        this.newLineIfNewLineOnNextWrite();
        if (this._text.length > 0)
            this.newLineIfLastNotNewLine();
        this.writeIndentingNewLines(str);
        this.newLine();
        return this;
    };
    CodeBlockWriter.prototype.newLineIfLastNotNewLine = function () {
        this.newLineIfNewLineOnNextWrite();
        if (!this.isLastCharANewLine())
            this.newLine();
        return this;
    };
    CodeBlockWriter.prototype.blankLine = function () {
        return this.newLineIfLastNotNewLine().newLine();
    };
    CodeBlockWriter.prototype.indent = function () {
        this.newLineIfNewLineOnNextWrite();
        return this.write(this._indentationText);
    };
    CodeBlockWriter.prototype.conditionalNewLine = function (condition) {
        if (condition)
            this.newLine();
        return this;
    };
    CodeBlockWriter.prototype.newLine = function () {
        this._newLineOnNextWrite = false;
        this.baseWriteNewline();
        return this;
    };
    CodeBlockWriter.prototype.quote = function (text) {
        this.newLineIfNewLineOnNextWrite();
        this.writeIndentingNewLines(text == null ? this._quoteChar : this._quoteChar + text + this._quoteChar);
        return this;
    };
    CodeBlockWriter.prototype.spaceIfLastNotSpace = function () {
        this.newLineIfNewLineOnNextWrite();
        var lastChar = this.getLastChar();
        if (lastChar !== " ")
            this.writeIndentingNewLines(" ");
        return this;
    };
    CodeBlockWriter.prototype.conditionalWrite = function (condition, text) {
        if (condition)
            this.write(text);
        return this;
    };
    CodeBlockWriter.prototype.write = function (text) {
        this.newLineIfNewLineOnNextWrite();
        this.writeIndentingNewLines(text);
        return this;
    };
    CodeBlockWriter.prototype.getLength = function () {
        return this._text.length;
    };
    CodeBlockWriter.prototype.isInComment = function () {
        return this._currentCommentChar !== undefined;
    };
    CodeBlockWriter.prototype.isInString = function () {
        return this._stringCharStack.length > 0 && this._stringCharStack[this._stringCharStack.length - 1] !== "{";
    };
    CodeBlockWriter.prototype.toString = function () {
        return this._text;
    };
    CodeBlockWriter.prototype.writeIndentingNewLines = function (text) {
        var _this = this;
        var items = (text || "").split(/\r?\n/);
        items.forEach(function (s, i) {
            if (i > 0)
                _this.baseWriteNewline();
            if (s.length === 0)
                return;
            var isAtStartOfLine = _this.isLastCharANewLine() || _this._text.length === 0;
            if (isAtStartOfLine && !_this.isInString())
                _this.writeIndentation();
            _this.updateStringStack(s);
            _this._text += s;
        });
    };
    CodeBlockWriter.prototype.baseWriteNewline = function () {
        if (this._currentCommentChar === CommentChar_1.CommentChar.Line)
            this._currentCommentChar = undefined;
        this._text += this._newLine;
    };
    CodeBlockWriter.prototype.updateStringStack = function (str) {
        for (var i = 0; i < str.length; i++) {
            var currentChar = str[i];
            var pastChar = i === 0 ? this.getLastChar() : str[i - 1];
            var lastCharOnStack = this._stringCharStack.length === 0 ? undefined : this._stringCharStack[this._stringCharStack.length - 1];
            if (this._currentCommentChar == null && pastChar === "/" && currentChar === "/")
                this._currentCommentChar = CommentChar_1.CommentChar.Line;
            else if (this._currentCommentChar == null && pastChar === "/" && currentChar === "*")
                this._currentCommentChar = CommentChar_1.CommentChar.Star;
            else if (this._currentCommentChar === CommentChar_1.CommentChar.Star && pastChar === "*" && currentChar === "/")
                this._currentCommentChar = undefined;
            if (this.isInComment())
                continue;
            else if (currentChar === "\"" || currentChar === "'" || currentChar === "`") {
                if (lastCharOnStack === currentChar)
                    this._stringCharStack.pop();
                else if (lastCharOnStack === "{" || lastCharOnStack === undefined)
                    this._stringCharStack.push(currentChar);
            }
            else if (pastChar === "$" && currentChar === "{" && lastCharOnStack === "`")
                this._stringCharStack.push(currentChar);
            else if (currentChar === "}" && lastCharOnStack === "{")
                this._stringCharStack.pop();
        }
    };
    CodeBlockWriter.prototype.isLastCharANewLine = function () {
        return this._text.indexOf(this._newLine, this._text.length - this._newLine.length) !== -1;
    };
    CodeBlockWriter.prototype.getLastChar = function () {
        if (this._text.length === 0)
            return undefined;
        return this._text[this._text.length - 1];
    };
    CodeBlockWriter.prototype.writeIndentation = function () {
        this._text += Array(this._currentIndentation + 1).join(this._indentationText);
    };
    CodeBlockWriter.prototype.newLineIfNewLineOnNextWrite = function () {
        if (!this._newLineOnNextWrite)
            return;
        this._newLineOnNextWrite = false;
        this.newLine();
    };
    return CodeBlockWriter;
}());
exports.default = CodeBlockWriter;
function getIndentationText(useTabs, numberSpaces) {
    if (useTabs)
        return "\t";
    return Array(numberSpaces + 1).join(" ");
}
function getSpacesAndTabsCount(str) {
    var spacesCount = 0;
    var tabsCount = 0;
    for (var _i = 0, str_1 = str; _i < str_1.length; _i++) {
        var char = str_1[_i];
        if (char === "\t")
            tabsCount++;
        else if (char === " ")
            spacesCount++;
    }
    return { spacesCount: spacesCount, tabsCount: tabsCount };
}
